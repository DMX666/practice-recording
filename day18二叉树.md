# day18
## t513[找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)
### 初始思路
  - 一直向左查找，直到找到一个最左的节点
  - 问题：这样的方法是有问题的，因为这里对于最左下的值每理解到位
### 学习收获([学习资源](https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html#%E6%80%9D%E8%B7%AF))
  - 这里最左下角，其实是最后一行的左起第一个元素，那么一直向左找是找不到的，因为最左的不一定在最后一行
  - 既然提到了行，那么用层序遍历是最简洁的，每次都记录最左边的元素，当遍历到最后一行的时候，也记录下来，就可以得到最终的结果
  <code> while(!que.isEmpty()){
            int size = que.size();
            for(int i=0; i<size; i++)</code>
  <code> while(!que.isEmpty()){       
            for(int i=0; i<que.size(); i++)</code>
  - 上面这两段代码看起来很像，甚至一样，但是并不是，后一种代码并不能成功，que.size()是**实时获取**队列长度的，在调用poll的时候进行了修改，那么也会跟着修改
## t112[路径总和](https://leetcode.cn/problems/path-sum/) t113[路径总和2](https://leetcode.cn/problems/path-sum-ii/description/)
### 学习收获
  - 遍历顺序：该题不需要中间节点进行操作处理，什么遍历顺序都可以
  - 什么时候需要返回参数，如果二叉树搜索整个且不需要处理返回值（不需要）；如果二叉树搜索整个且需要处理返回值（需要）；如果不必须搜索整个二叉树，只需要找到合适的就返回（需要返回值及时终止查找）
  - 参数：当前节点，计数器（用来帮助计算是否符合总和），用递减，而非累加，递减更方便
  - 终止条件：遇到叶子节点，递减为0则找到了，递减不为0，没有找到
  - 单层逻辑，遍历左右子节点（不为零），遇到合适路径立即返回
    - 注意要进行回溯
  - 在113题中，寻找所有的路径，那么这里要搜索整个二叉树，所以返回值是void，但是参数就有很多，当前节点cur,结果res,当前路径path,计数器count
  - 这题中每个遍历的终点是遇到叶子节点，可能是路径（加入结果List），也可能不是路径return
  - 单层逻辑，对左边进行递归，对右边进行递归，一定要记得回溯
